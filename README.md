<div>
<!-- Generated by cxt.py from INFO.cxt -->
<h1>civc: civboot C library (<span><a href="http://civboot.org">http://civboot.org</a></span>)</h1>
civc is a small C library embodying Civboot&#x27;s software design principles. It is primarily to bootstrap 
<span><a href="https://github.com/civboot/fngi">fngi</a></span>
, but is made available if others would like to experiment with similar minimalist software stacks in C. Installation is done by simply copying the 
<code>civ</code>
 directory and including the relevant files for your program.<p>The fngi runtime depends on the following, which are provided by civc: 
<ul><li>Core data types including Slc, Buf, CStr (byte counted string), Ring buffer, SLL and DLL (single/double linked lists), and BST (binary search tree) -- as well as common methods and safe type conversion functions.</li><li>A 0x1000 byte (4KiB)  block allocator, permitting allocating and freeing single blocks without memory fragmentation.</li><li>A basic arena allocator allowing allocation and freeing of both aligned and non-aligned memory.</li><li>A File Role type, permitting reading and writing to byte stream resources through standardized method pointer offsets (see Role section).</li><li>A basic concept of Fibers, allowing for implementing a cooperatively scheduled system on top.</li><li>A global environment for the allocated values, giving implementors a standard base to interact with their environment.</li></ul>
<h2>Data Inheritance</h2>
Inheritance in civc is simple. If the beginning of your struct is laid out identically to another struct, then it 
<i>can</i>
 be a child of that struct and the pointer can safely be converted. For example:<p>
<pre>struct A { int a; };<br>struct B { int a; int b; }<br></pre>
A pointer of type B can be converted safely to a pointer of type A, since B contains all of A&#x27;s fields. We therefore write the function: 
<pre>A* B_asA(B* b) { return (A*)b; }<br></pre>
<blockquote> Converting the other way (from A to B) is not safe and should not be written. </blockquote>
This is most commonly used for child structs of data structures like linked lists. Being able to convert pointer types allows us to write logic for these types once and reuse it for any other shape of the payload. Writing the safe conversions helps prevent us from accidentally doing invalid conversions.<p>
<h2>Role</h2>
Roles allow cheap abstractions for things like allocating, file reading, or other behavior with a common API but many possible implementations and data layouts depending on the hardware and use case.<p>
<blockquote> Roles are very similar to interfaces in other languages, but boiled down to the most minimal possible implementation. </blockquote>
An instance of a Role is composed of two things: 
<ul><li>A pointer to a global struct value who&#x27;s members are pointers to functions (aka methods).</li><li>A pointer to that instance&#x27;s data.</li></ul>
In code this simply looks like: 
<pre><br>// A Role is just a collection of methods and some data.<br>typedef struct {<br>  void (*add)(void* this, int a); // pointer to add method<br>  ... other methods<br>} MExampleRole;<br><br>typedef struct {<br>  MExampleRole* m, // a pointer to methods<br>  void* d;         // a pointer to data of an unknown type<br>} ExampleRole;<br><br>// Creating something that implements the role:<br><br>typedef struct {int a;} ExampleInstance;<br><br>// defines:<br>// - ExampleInstance_add function.<br>// - M_ExampleInstance_add method pointer.<br>METHOD_DEFINE(/*return*/void, ExampleInstance,add, int a) {<br>  this-&gt;a += a;<br>}<br><br>METHODS_DEFINE(MExampleRole, ExampleInstance_mExampleRole,<br>  .add  = M_ExampleInstance_add,<br>)<br><br>ExampleRole ExampleInstance_asExampleRole(ExampleInstance* d) {<br>  return (ExampleRole) { .m = ExampleInstance_mExampleRole, .d = d };<br>}<br></pre>
The role can then be used like: 
<pre>ExampleInstance d = {0};<br>ExampleInstance_add(&amp;d, 4);<br>ExampleRole r = ExampleInstance_asExampleRole(&amp;d);<br>Xr(r, add, 4); // macro to call role method add<br>assert(d.a == 8);<br></pre>
It&#x27;s a fair amount of boilerplate in C, but it is EXTREMELY simple and performant. Also, using a role is much easier than defining one, which is good since they are used extensively. See civ/civ.h for more documentation.<p>
<blockquote> Since a role is only two pointers, best practice is to take them by value (not by pointer). I.e. &quot;myFunction(MyRole role, int arg)&quot; </blockquote>
<h2>Differences with &quot;normal&quot; C</h2>
The civc software stack (fngi) shares much of the C design philosophy. This includes control over memory layout and management as a central element, as well as imperative bitwise operations and logic. Unlike C, it defines a few basic data types and algorithms for manipulating them in it&#x27;s std library.<p>The C std library has APIs that are heavily system dependant and are very tied to the unix philosophy and syscall APIs, which include hardware-heavy technology like virtual memory (handling fragmentation in hardware), preemptive multitasking and byte buffer streams. In contrast, civc provides only a block allocator, cooperative multitasking and block/sector passing.<p>civc is built to run on simpler hardware, with suitable abstractions (Roles) for running on more powerful hardware. Core types can work with small allocators while still working fine with larger allocators as well.<p>More details: 
<ul><li>C has no generic resource encapsulation. Civc uses Roles for this, allowing for implementing common behaviors like reading an entire file for any kind of file-like object.</li><li>Dynamic memory management in C practically requires virtual memory, and therefore cannot be implemented on minimal hardware. Civc&#x27;s core types only require a block allocator, so can be implemented on almost any hardware. Civc also uses a Role object for it&#x27;s arena allocators, allowing a range of possibilities for their implementation depending on the hardware or use-case.</li><li>Because civc is block-based, passing blocks of memory between processes should be trivial to implement at the kernel level (the kernel can keep track of who owns what block). Passing blocks and sectors of memory is much more efficient than passing bytes. While such a thing is possible in C, it is far from simple.</li><li>Core types typically have attributes like length and capacity included, and can be safely converted between each other. This reduces programmer error and permits efficient re-use of code.</li><li>Quality of life: known-sized types like I4 and U2 are standard. Civc believes that known constraints are better than &quot;growing with the hardware&quot; for systems programming. The Slot type (size_t) is the exception, since the size of a pointer must be system dependent.</li></ul>
<h2>Growth of a new language</h2>
The primary purpose of civc is to provide a tested foundation for the 
<span><a href="https://github.com/civboot/fngi">fngi</a></span>
 language. Like C, fngi is low level. Unlike C, fngi&#x27;s macros are powerful enough to inspect types and alter the syntax of the language inline. This means that it can easily build the Role types in a library using macros.<p>Besides civc, which itself is a very small set of data structures, fngi is intended to be a very minimalist language to bootstrap, requring only about 1000 lines of C beyond what is in civc (which itself is very minimalistic).<p>
<h2>License</h2>
civc is part of the 
<span><a href="https://civboot.org">Civboot</a></span>
 project and is released to the public domain or licensed MIT under your discression. Modify this directory in any way you wish. Contributions are welcome.<p>


</div>
